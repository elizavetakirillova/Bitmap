# Bitmap

 Проект ELTEX July 2023

Библиотека bitmap предоставляет функции для работы со структурой Bitmap.
Bitmap - это структура данных, которая позволяет компактно хранить биты.

Детали реализации:
1. Реализация в виде статической и динамической библиотек
2. Наличие структуры данных bitmap
3. Наличие инициатора/деинициализатора
4. Наличие произвольного доступа и редактирования битов в структуре
5. Реализация выполнения побитовых операторов для двух bitmap: AND, OR, XOR
6. Реализация NOT
7. Реализация сравнения двух структур данных: строго больше, больше, равно, меньше, строго меньше
8. Реализация функционала копирования
9. Реализация функционала клонирования
10. Реализация функционала сброса структуры данных
11. Проверка работоспособности автотестами 


# Сборка проекта Bitmap

Собрать проект можно при помощи утилиты *make*

## Сборка проекта при помощи make

Для сборки проекта через статическую библиотеку необходимо выполнить команду

```
$ make 
```

Либо команду

```
$ make static
```

Для сборки проекта через динамическую библиотеку необходимо выполнить команду

```
$ make dyn
```

Для запуска проекта выполните 

```
$ make run
```
Для очистки проекта выполните

```
$ make clean_all
```


### Функции:
```
myError_e create_bitmap(bitmap_t **ptr_new, int bits)
```
Принимает указатель на создаваемую структуру bitmap и количество битов bits. 
Возвращает код успешного выполнения/ошибки типа myError. Создает новую структуру 
bitmap c количеством бит bits.

```
myError_e copy_bitmap(bitmap_t **ptr, bitmap_t *ptr_copied)
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения
/ошибки типа myError. Копирует содержимое одной структуры в другую.

```
myError_e clone_bitmap(bitmap_t **ptr_clone, bitmap_t *ptr)
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения
/ошибки типа myError. Клонирует содержимое одной структуры в другую.

```
myError_e realloc_bits(bitmap_t **ptr, int bits)
```
Принимает указатель на структуру bitmap. Возвращает код успешного выполнения
/ошибки типа myError. Увеличивает количество памяти выделяемой под структуру bitmap.

```
myError_e glue_bitmap(bitmap_t **ptr_1, bitmap_t *ptr_2)
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения
/ошибки типа myError. Соединяет две структуры вместе.

```
myError_e add_bit_to_bitmap(bitmap_t **ptr_1, int bits)
```
Принимает указатель на структуру bitmap и количество бит bits. Возвращает код 
успешного выполнения/ошибки типа myError. Добавляет bits бит в сруктуру bitmap.

```
myError_e destroy_bits(bitmap_t **ptr)
```
Принимает указатель на структуру bitmap. Возвращает код успешного выполнения
/ошибки типа myError. Освобождает память, выделенную под указатель bitmap.

```
myError_e and_op(bitmap_t **ptr_1, bitmap_t **ptr_2) 
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения 
/ошибки типа myError. Выполнение побитовой операции AND для двух bitmap.

```
myError_e or_op(bitmap_t **ptr_1, bitmap_t **ptr_2)
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения 
/ошибки типа myError. Выполнение побитовой операции OR для двух bitmap.

```
myError_e xor_op(bitmap_t **ptr_1, bitmap_t **ptr_2)
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения 
/ошибки типа myError. Выполнение побитовой операции XOR для двух bitmap.

```
myError_e not_op(bitmap_t **ptr)
```
Принимает указатель на структуру bitmap. Возвращает код успешного выполнения 
/ошибки типа myError. Выполнение побитовой оператоции NOT для bitmap.

```
myError_e set_bit(bitmap_t **ptr, int num, int val)
```
Принимает указатель на структуру bitmap, номер бита, который необходимо изменить 
(num), и значение val, на которое необходимо изменить (0/1). Возвращает код 
успешного выполнения/ошибки типа myError. Изменяет num-й бит в val 0/1.

```
myError_e show_bitmap(bitmap_t **ptr)
```
Принимает указатель на структуру bitmap. Возвращает код успешного 
выполнения/ошибки типа myError. Выводит на экран значения bitmap.

```
myError_e to_default_value(bitmap_t **ptr, int num_bits)
```
Принимает указатель на структуру bitmap и значение для установления значения всех битов (0/1). 
Возвращает код успешного выполнения/ошибки типа myError. Инициализирует структуру 
bitmap значением 0/1.

```
int get_bit(bitmap_t **ptr, int num_bits)
```
Принимает указатель на структуру bitmap и номер бита.
Возвращает значение данного бита.

```
myError_e compare_bitmaps_length(bitmap_t **ptr_1, bitmap_t **ptr_2) 
```
Принимает два указателя на структуру bitmap. Возвращает код успешного выполнения 
/ошибки типа myError. Сравнение двух структур данных: равно, строго больше, больше, 
строго меньше, меньше.

```
myError_e calloc_bits(bitmap_t **ptr)
```
Принимает указатель на структуру bitmap. Возвращает код успешного выполнения
/ошибки типа myError. Выделяет запрошенный пользователем объем памяти под bits.

```
myError_e bitmap_new(bitmap_t **ptr_new)
```
Принимает указатель на создаваемую структуру bitmap и количество битов.
Возвращает код успешного выполнения/ошибки типа myError. Выделяет память под указатель.*/

### Пример создания битмапа и вызова функций.
Для создания битмапа необходимо создать структуру типа bitmap_t.

```
bitmap_t *bitmap_1;
```
Затем выполнить функцию create_bitmap передав адрес на битмап и нужное вам количество 
битов.

```
create_bitmap(&bitmap_1, 43);
```

будет выделена память под битмап в размере 6 байт (48 бит)
Для вывода битмапа используйте функцию show_bitmap, передав адрес на битмап

```
show_bitmap(&bitmap_1);
```
на экране будет ввыведен бидмап в виде 48 нулей 

```
000000000000000000000000000000000000000000000000
```

для инициализации битмап всем единицами используйте функцию to_default_value передав
адрес на битмап и единицу или ноль 1\0 в зависимоти от того чем хотите заполнить
битмап.

```
to_default_value(&bitmap_1, 1);
```

и битмап будет равен 

```
111111111111111111111111111111111111111111111111
```
для побитовых операций
спомощью функции set_bit передав адрес на битмап, номер бита и единицу или ноль 1\0
можно изменить значение бита

```
set_bit(&bitmap_1, 33, 0);
```
33 бит в битмапе изменится на 0
```
111111111111111111111111111111111011111111111111
```
при использовании not_op можно инверсировать значения битмапа
передеаем адрес

```
not_op(&bitmap_1);
```
тепер выгялдеть битмап будет так
```
000000000000000000000000000000000100000000000000
```

используйте функции and_op, or_op, xor_op для побитовых опираций передвая два адреса 
на два разных битмапа с которыми хотите сделать оперцию

для вызова функции clone_bitmap нужно создать новую структуру типа bitmap_t 
и передать адрес на новый битмап и указатель на клонируемый битмап
например 

```
bitmap_t *bitmap_new;
```

и вызвать функцию clone_bitmap

```
clone_bitmap(&bitmap_new, bitmap_1);
```

теперь если вызвать show_bitmap

```
show_bitmap(&bitmap_new);
```
на экране будет ввыведен бидмап такой же как и bitmap_1

```
000000000000000000000000000000000100000000000000
```
можно объединить два битмапа при помощи функции glue_bitmap передав адрес битмапа
к которому будем прикреплять и указатель на битмап который будем прикреплять

```
glue_bitmap(&bitmap_new, ptr);
```
наш битмап при вызове show_bitmap(&bitmap_new); ввыведет 

```
000000000000000000000000000000000100000000000000000000000000000000000000000000000100000000000000
```

так же можно просто добавить биты к созданому битмапу через функцию add_bit_to_bitmap
передав адрес битмапа и количество битов на которое хотите увеличить битмап

```
add_bit_to_bitmap(&bitmap_1, 10);
```

битмап bitmap_1 будет увеличен на 2 байта (16 бит)

и будет выгялдеть так 

```
0000000000000000000000000000000001000000000000000000000000000000
```

для вывода определеного бита используйте get_bit передав адрес на битмап и номер бита
get_bit возвращает значение типа int.
```
printf ("5 bit = %d\n", get_bit(bitmap_1, 5));
printf ("33 bit = %d\n", get_bit(bitmap_1, 33));
```
на экран будет

```
5 bit = 0
33 bit = 1
```

для деинициализации используйте функцию destroy_bits передав адрес на битмап

```
destroy_bits(&bitmap_1);
destroy_bits(&bitmap_new);
```


